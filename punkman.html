<html>

<head>
    <title>Punk man</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

    <script type="text/javascript" src="js/glMatrix-0.9.5.min.js"></script>
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script type="text/javascript" src="js/webgl-utils.js"></script>
    <script type="text/javascript" src="js/find_path.js"></script>
    
    <!--    <script type="text/javascript" src="js/odometer.min.js"></script>-->
    <script src="http://github.hubspot.com/odometer/odometer.js"></script>
    <link rel="stylesheet" href="http://github.hubspot.com/odometer/themes/odometer-theme-train-station.css" />
    <!--    <link rel="stylesheet" href="css/odometer-theme-slot-machine.css" />-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link rel="stylesheet" href="css/bootstrap-theme.min.css" />
<!--      <link rel="stylesheet" href="css/bootstrap.min.css" />-->
    
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTextureCoord;

        uniform sampler2D uSampler;

        void main(void) {

            vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
            gl_FragColor = vec4(textureColor.rgb, textureColor.a);

        }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;

        attribute vec2 aTextureCoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec2 vTextureCoord;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vTextureCoord = aTextureCoord;
        }
    </script>


    <script type="text/javascript">
        var gl;

        function initGL(canvas) {
            try {
                gl = canvas.getContext("experimental-webgl");
                gl.viewportWidth = canvas.width;
                gl.viewportHeight = canvas.height;
            } catch (e) {}
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }


        function getShader(gl, id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;

            }

            var str = "";
            var k = shaderScript.firstChild;
            while (k) {
                if (k.nodeType == 3) {
                    str += k.textContent;
                }
                k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "x-shader/x-fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (shaderScript.type == "x-shader/x-vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, str);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }


        var shaderProgram;

        function initShaders() {
            var fragmentShader = getShader(gl, "shader-fs");
            var vertexShader = getShader(gl, "shader-vs");

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        }


        function handleLoadedTexture(textures) {
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);


            gl.bindTexture(gl.TEXTURE_2D, textures);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures.image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);

            gl.bindTexture(gl.TEXTURE_2D, null);
        }


        var floor_texture;
        var pacman_texture;
        var maze_texture;
        var pellet_texture;
        var power_pellet_texture;
        var ghost1_texture;
        var ghost2_texture;
        var ghost3_texture;
        var ghost4_texture;
        var ghostf_texture;
        var background_texture;
        var pellet_map;


        function initTexture() {



            floor_texture = gl.createTexture();
            floor_texture.image = new Image();
            floor_texture.image.onload = function() {
                handleLoadedTexture(floor_texture)
            }
            floor_texture.image.src = "img/grass.jpg";



            pacman_texture = gl.createTexture();
            pacman_texture.image = new Image();
            pacman_texture.image.onload = function() {
                handleLoadedTexture(pacman_texture)
            }
            pacman_texture.image.src = "img/face.png";

            pellet_texture = gl.createTexture();
            pellet_texture.image = new Image();
            pellet_texture.image.onload = function() {
                handleLoadedTexture(pellet_texture)
            }
            pellet_texture.image.src = "img/pellet.png";

            power_pellet_texture = gl.createTexture();
            power_pellet_texture.image = new Image();
            power_pellet_texture.image.onload = function() {
                handleLoadedTexture(power_pellet_texture)
            }
            power_pellet_texture.image.src = "img/power_pellet.png";


            maze_texture = gl.createTexture();
            maze_texture.image = new Image();
            maze_texture.image.onload = function() {
                handleLoadedTexture(maze_texture)
            }
            //            maze_texture.image.src = "wall.gif";
            maze_texture.image.src = "img/wall2.png";


            ghost1_texture = gl.createTexture();
            ghost1_texture.image = new Image();
            ghost1_texture.image.onload = function() {
                handleLoadedTexture(ghost1_texture)
            }
            ghost1_texture.image.src = "img/ghost.jpg";

            ghost2_texture = gl.createTexture();
            ghost2_texture.image = new Image();
            ghost2_texture.image.onload = function() {
                handleLoadedTexture(ghost2_texture)
            }
            ghost2_texture.image.src = "img/ghost2.jpg";

            ghost3_texture = gl.createTexture();
            ghost3_texture.image = new Image();
            ghost3_texture.image.onload = function() {
                handleLoadedTexture(ghost3_texture)
            }
            ghost3_texture.image.src = "img/ghost3.jpg";

            ghost4_texture = gl.createTexture();
            ghost4_texture.image = new Image();
            ghost4_texture.image.onload = function() {
                handleLoadedTexture(ghost4_texture)
            }
            ghost4_texture.image.src = "img/ghost4.jpg";

            // Texture gia vulnerable ghost
            ghostf_texture = gl.createTexture();
            ghostf_texture.image = new Image();
            ghostf_texture.image.onload = function() {
                handleLoadedTexture(ghostf_texture)
            }
            ghostf_texture.image.src = "img/ghost.png";
            
            // Texture gia vulnerable ghost
            background_texture = gl.createTexture();
            background_texture.image = new Image();
            background_texture.image.onload = function() {
                handleLoadedTexture(background_texture)
            }
            background_texture.image.src = "img/background2.jpg";
            
            

            pellet_map = stage.slice();

        }


        var mvMatrix = mat4.create();
        var mvMatrixStack = [];
        var pMatrix = mat4.create();

        function mvPushMatrix() {
            var copy = mat4.create();
            mat4.set(mvMatrix, copy);
            mvMatrixStack.push(copy);
        }

        function mvPopMatrix() {
            if (mvMatrixStack.length == 0) {
                throw "Invalid popMatrix!";
            }
            mvMatrix = mvMatrixStack.pop();
        }


        function setMatrixUniforms() {
            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
            
            var normalMatrix = mat3.create();
            mat4.toInverseMat3(mvMatrix, normalMatrix);
            mat3.transpose(normalMatrix);
            gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
        }


        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }
		
		var stage = [

            ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'U', 'x', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'x', 'U', 'x'],
            ['x', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'x'],
            ['x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x'],
            ['x', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'x'],
            ['x', 'U', 'x', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'x', 'U', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],

        ];

		
		var stage1 = [

            ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'U', 'x', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'x', 'U', 'x'],
            ['x', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'x'],
            ['x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x'],
            ['x', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'x'],
            ['x', 'U', 'x', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'x', 'U', 'x'],
            ['x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x'],
            ['x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],

        ];

		

  var stage2 = [

            ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],            
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],            
            ['x', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x'],            
            ['x', 'U', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'U', 'x'],            
            ['x', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],            
            ['x', 'p', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x'],            
            ['x', 'p', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'p', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],            
            ['x', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x'],            
            ['x', 'U', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'p', 'U', 'x'],            
            ['x', 'p', 'x', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],            
            ['x', 'p', 'x', 'p', 'x', 'x', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],            
            ['x', 'p', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'p', 'x', 'x', 'x', 'x', 'x', 'p', 'x'],            
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p', 'x', 'p', 'p', 'p', 'p', 'p'],
            ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'],

        ];



        var xRot = 0;
        var xSpeed = 0;

        var ySpeed = 0;

        var z = -20.0;
        var a = 0;
        var b = 0;
        var zRot = 0;

        var filter = 2;

        var xStage = -20;
        var yStage = 20;
        var lives = 3;



        var currentlyPressedKeys = {};

         ////////////
        var pacRot = 90; //default thesi na se koitaei to pacman
        var x = 0; //suntetagmenes aristera-deksia pacman
        var y = 1; //suntetagmenes panw-katw pacman


        var x1 = 18;
        var y1 = 1;
        var x2 = 18;
        var y2 = 9;
        var x3 = 18;
        var y3 = 17;
        var x4 = 0;
        var y4 = 9;




        var memory_key = "R";
        var prev_key;

        function handleKeyDown(event) {
            var temp;
            currentlyPressedKeys[event.keyCode] = true;

            prev_key = memory_key;



            if (String.fromCharCode(event.keyCode) == "A") {

                if (Math.round(x) == 0) { //MAGIC DOOR teleport
                    x = 18;
                } else {
                    if (((x - 1) < 0) || (stage[Math.round(y)][Math.round(x) - 1] == "x")) {
                        memory_key = prev_key;
                    } else {
                        memory_key = "A";
                        pacRot = 0;
                    }
                }
            }
            if (String.fromCharCode(event.keyCode) == "D") {

                if (Math.round(x) == 18) { //MAGIC DOOR teleport
                    x = 0;
                } else {
                    if (((x + 1) > 18) || (stage[Math.round(y)][Math.round(x) + 1] == "x")) {
                        memory_key = prev_key;
                    } else {
                        memory_key = "D";
                        pacRot = 180;
                    }
                }
            }
            if (String.fromCharCode(event.keyCode) == "W") {

                if (((y - 1) < 0) || (stage[Math.round(y) - 1][Math.round(x)] == "x")) {
                    memory_key = prev_key;
                } else {
                    memory_key = "W";
                    pacRot = 270;
                }
            }
            if (String.fromCharCode(event.keyCode) == "S") {

                if (((y + 1) > 18) || (stage[Math.round(y) + 1][Math.round(x)] == "x")) {
                    memory_key = prev_key;
                } else {
                    memory_key = "S";
                    pacRot = 90;
                }

            }







        }


        function handleKeyUp(event) {
            currentlyPressedKeys[event.keyCode] = false;

        }


        function handleKeys() {
            if (currentlyPressedKeys[189]) {
                // Page Up
                z1 -= 1;
            }
            if (currentlyPressedKeys[187]) {
                // Page Down
                z1 += 1;
            }
            if (currentlyPressedKeys[37]) {
                // Left cursor key
                xStage++;
            }
            if (currentlyPressedKeys[39]) {
                // Right cursor key
                xStage--;
            }
            if (currentlyPressedKeys[38]) {
                // Up cursor key
                yStage--;
            }
            if (currentlyPressedKeys[40]) {
                // Down cursor key
                yStage++;
            }
            if (currentlyPressedKeys[36]) {
                // Home Key
                yRot++;
            }
            if (currentlyPressedKeys[35]) {
                // END key
                yRot--;
            }
        }


         // buffer gia to lavurintho
        var mazeVertexPositionBuffer;
        var mazeVertexTextureCoordBuffer;
        var mazeVertexIndexBuffer;

         //buffer gia to pacman
        var pacmanVertexPositionBuffer;
        var pacmanVertexNormalBuffer;
        var pacmanVertexTextureCoordBuffer;
        var pacmanVertexIndexBuffer;



         //buffer gia to patwma
        var floorVertexPositionBuffer;
        var floorVertexTextureCoordBuffer;
        var floorVertexIndexBuffer;




        function initBuffers() {

            //////////             Initialise floor Buffer   ///////////////////////////////////////////////////////////////
            floorVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexPositionBuffer);
            vertices = [
                // Front face
                -1.0, -1.0, 1.0,
                1.0, -1.0, 1.0,
                1.0, 1.0, 1.0, -1.0, 1.0, 1.0,

                // Back face
                -1.0, -1.0, -1.0, -1.0, 1.0, -1.0,
                1.0, 1.0, -1.0,
                1.0, -1.0, -1.0,

                // Top face
                -1.0, 1.0, -1.0, -1.0, 1.0, 1.0,
                1.0, 1.0, 1.0,
                1.0, 1.0, -1.0,

                // Bottom face
                -1.0, -1.0, -1.0,
                1.0, -1.0, -1.0,
                1.0, -1.0, 1.0, -1.0, -1.0, 1.0,

                // Right face
                1.0, -1.0, -1.0,
                1.0, 1.0, -1.0,
                1.0, 1.0, 1.0,
                1.0, -1.0, 1.0,

                // Left face
                -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            floorVertexPositionBuffer.itemSize = 3;
            floorVertexPositionBuffer.numItems = 24;

            floorVertexTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexTextureCoordBuffer);
            var textureCoords = [
                // Front face
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,

                // Back face
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,

                // Top face
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,

                // Bottom face
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,

                // Right face
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,

                // Left face
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
            floorVertexTextureCoordBuffer.itemSize = 2;
            floorVertexTextureCoordBuffer.numItems = 24;

            floorVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorVertexIndexBuffer);
            var floorVertexIndices = [
                0, 1, 2, 0, 2, 3, // Front face
                4, 5, 6, 4, 6, 7, // Back face
                8, 9, 10, 8, 10, 11, // Top face
                12, 13, 14, 12, 14, 15, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 21, 22, 20, 22, 23 // Left face
            ]
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(floorVertexIndices), gl.STATIC_DRAW);
            floorVertexIndexBuffer.itemSize = 1;
            floorVertexIndexBuffer.numItems = 36;



            ///////////// Initialise maze buffer   /////////////////////////////////////////////////////////////////////////////
            mazeVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mazeVertexPositionBuffer);
            vertices = [
                // Front face
                -1.0, -1.0, 1.0,
                1.0, -1.0, 1.0,
                1.0, 1.0, 1.0, -1.0, 1.0, 1.0,

                // Back face
                -1.0, -1.0, -1.0, -1.0, 1.0, -1.0,
                1.0, 1.0, -1.0,
                1.0, -1.0, -1.0,

                // Top face
                -1.0, 1.0, -1.0, -1.0, 1.0, 1.0,
                1.0, 1.0, 1.0,
                1.0, 1.0, -1.0,

                // Bottom face
                -1.0, -1.0, -1.0,
                1.0, -1.0, -1.0,
                1.0, -1.0, 1.0, -1.0, -1.0, 1.0,

                // Right face
                1.0, -1.0, -1.0,
                1.0, 1.0, -1.0,
                1.0, 1.0, 1.0,
                1.0, -1.0, 1.0,

                // Left face
                -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            mazeVertexPositionBuffer.itemSize = 3;
            mazeVertexPositionBuffer.numItems = 24;

            mazeVertexTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, mazeVertexTextureCoordBuffer);
            var textureCoords = [
                // Front face
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,

                // Back face
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,

                // Top face
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,

                // Bottom face
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0,

                // Right face
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,

                // Left face
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
            mazeVertexTextureCoordBuffer.itemSize = 2;
            mazeVertexTextureCoordBuffer.numItems = 24;

            mazeVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mazeVertexIndexBuffer);
            var mazeVertexIndices = [
                0, 1, 2, 0, 2, 3, // Front face
                4, 5, 6, 4, 6, 7, // Back face
                8, 9, 10, 8, 10, 11, // Top face
                12, 13, 14, 12, 14, 15, // Bottom face
                16, 17, 18, 16, 18, 19, // Right face
                20, 21, 22, 20, 22, 23 // Left face
            ]
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mazeVertexIndices), gl.STATIC_DRAW);
            mazeVertexIndexBuffer.itemSize = 1;
            mazeVertexIndexBuffer.numItems = 36;

            ////////////////     Initialise pacman buffer //////////////////////////////////
            var latitudeBands = 30;
            var longitudeBands = 30;
            var radius = 2;

            var vertexPositionData = [];
            var normalData = [];
            var textureCoordData = [];

            for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                var theta = latNumber * Math.PI / latitudeBands;
                var sinTheta = Math.sin(theta);
                var cosTheta = Math.cos(theta);
                for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                    var phi = longNumber * 2 * Math.PI / longitudeBands;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);
                    var x = cosPhi * sinTheta;
                    var y = cosTheta;
                    var z = sinPhi * sinTheta;
                    var u = 1 - (longNumber / longitudeBands);
                    var v = 1 - (latNumber / latitudeBands);
                    normalData.push(x);
                    normalData.push(y);
                    normalData.push(z);
                    textureCoordData.push(u);
                    textureCoordData.push(v);
                    vertexPositionData.push(radius * x);
                    vertexPositionData.push(radius * y);
                    vertexPositionData.push(radius * z);
                }
            }
            var indexData = [];
            for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
                    var first = (latNumber * (longitudeBands + 1)) + longNumber;
                    var second = first + longitudeBands + 1;
                    indexData.push(first);
                    indexData.push(second);
                    indexData.push(first + 1);
                    indexData.push(second);
                    indexData.push(second + 1);
                    indexData.push(first + 1);
                }
            }
            pacmanVertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
            pacmanVertexNormalBuffer.itemSize = 3;
            pacmanVertexNormalBuffer.numItems = normalData.length / 3;
            pacmanVertexTextureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
            pacmanVertexTextureCoordBuffer.itemSize = 2;
            pacmanVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;
            pacmanVertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
            pacmanVertexPositionBuffer.itemSize = 3;
            pacmanVertexPositionBuffer.numItems = vertexPositionData.length / 3;
            pacmanVertexIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
            pacmanVertexIndexBuffer.itemSize = 1;
            pacmanVertexIndexBuffer.numItems = indexData.length;


        }

        var z1 = 0;
        var yRot = 71;

        var panoramic = true;

        function drawScene() {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 200.0, pMatrix);

            mat4.identity(mvMatrix);
            if (panoramic) {
                mat4.translate(mvMatrix, [xStage, yStage, -60]); //kanoniko
                mat4.rotate(mvMatrix, degToRad(yRot), [1, 0, 0]);
            } else { //tv view
                mat4.translate(mvMatrix, [0 - x * 2, 4 + y, -40]);
                mat4.rotate(mvMatrix, degToRad(35), [1, 0, 0]);
            }



            ////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////

            //var z1 = -40;


            
            mvPushMatrix();
                        mat4.translate(mvMatrix, [0,0, 0]);
                        mat4.rotate(mvMatrix, degToRad(0), [1, 0, 0]);
                        mat4.scale(mvMatrix, [200, 200 , 200]);
                        //mat4.rotate(mvMatrix, degToRad(-50),[0, 0, 1]); //rotate gia na se koitaei
                        mat4.scale(mvMatrix, [0.70, 0.7, 0.70]);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, background_texture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                        mvPopMatrix();

            

            for (var i = 0; i < 19; i++) {
                for (var j = 0; j < 19; j++) {

                    mvPushMatrix();

                    //mat4.translate(mvMatrix, [x,z1,y]);
                    mat4.translate(mvMatrix, [2 * j + 2, z1, 2 * i + 2]);
                    gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexPositionBuffer);
                    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, floorVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, floorVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, floor_texture);
                    gl.uniform1i(shaderProgram.samplerUniform, 0);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, floorVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();


                    if (stage[i][j] == "x") { // elegxos gia draw walls

                        mvPushMatrix();

                        if (panoramic) {
                            mat4.translate(mvMatrix, [2 * j + 2, z1 + 2, 2 * i + 2]);
                            mat4.scale(mvMatrix, [1, 1, 1]);
                        } else {
                            mat4.translate(mvMatrix, [2 * j + 2, z1 + 2 - 0.7, 2 * i + 2]);
                            mat4.scale(mvMatrix, [1, 0.4, 1]);
                        }

                        gl.bindBuffer(gl.ARRAY_BUFFER, mazeVertexPositionBuffer);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, mazeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, mazeVertexTextureCoordBuffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, mazeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, maze_texture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mazeVertexIndexBuffer);
                        setMatrixUniforms();
                        gl.drawElements(gl.TRIANGLES, mazeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                        mvPopMatrix();


                    }
                    if (pellet_map[i][j] == "p") { // elegxos gia koumpia
                        mvPushMatrix();
                        mat4.translate(mvMatrix, [2 * j + 2, z1 + 2, 2 * i + 2]);
                        mat4.rotate(mvMatrix, degToRad(35), [0, 1, 0]);
                        //mat4.rotate(mvMatrix, degToRad(-50),[0, 0, 1]); //rotate gia na se koitaei
                        mat4.scale(mvMatrix, [0.3, 0.3, 0.3]);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, pellet_texture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();


                    } else if (pellet_map[i][j] == "U") { // power pellets


                        mvPushMatrix();
                        mat4.translate(mvMatrix, [2 * j + 2, z1 + 2, 2 * i + 2]);
                        mat4.rotate(mvMatrix, degToRad(35), [0, 1, 0]);
                        //mat4.rotate(mvMatrix, degToRad(-50),[0, 0, 1]); //rotate gia na se koitaei
                        mat4.scale(mvMatrix, [0.70, 0.7, 0.70]);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, power_pellet_texture);
                        gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();

                    }
                }
            }
            mvPushMatrix();
            ////////////////// PACMAN /////////////////////////
            mat4.translate(mvMatrix, [2 * x + 2, z1 + 2, y * 2 + 2]);
            mat4.rotate(mvMatrix, degToRad(pacRot), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(-50), [0, 0, 1]); //rotate gia na se koitaei
            //mat4.scale(mvMatrix, [0.9, 0.9, 0.9 ]);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, pacman_texture);
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();




            ////////////////// GHOST1 /////////////////////////
            mvPushMatrix();
            mat4.translate(mvMatrix, [2 * x1 + 2, z1 + 2, 2 * y1 + 2]);
            mat4.rotate(mvMatrix, degToRad(80), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(-45), [0, 0, 1]); //rotate gia na se koitaei
            //mat4.scale(mvMatrix, [0.9, 0.9, 0.9 ]);
            gl.activeTexture(gl.TEXTURE0);

            gl.bindTexture(gl.TEXTURE_2D, ghost1_texture);
            if (power_pellet) {
                gl.bindTexture(gl.TEXTURE_2D, ghostf_texture);
            };
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();



            ////////////////// ghost2 /////////////////////////
            mvPushMatrix();
            mat4.translate(mvMatrix, [2 * x2 + 2, z1 + 2, 2 * y2 + 2]);
            mat4.rotate(mvMatrix, degToRad(80), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(-45), [0, 0, 1]); //rotate gia na se koitaei
            //mat4.scale(mvMatrix, [0.9, 0.9, 0.9 ]);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, ghost2_texture);
            if (power_pellet) {
                gl.bindTexture(gl.TEXTURE_2D, ghostf_texture);
            };
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();

            ////////////////// ghost3 /////////////////////////
            mvPushMatrix();
            mat4.translate(mvMatrix, [2 * x3 + 2, z1 + 2, 2 * y3 + 2]);
            mat4.rotate(mvMatrix, degToRad(80), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(-45), [0, 0, 1]); //rotate gia na se koitaei
            //mat4.scale(mvMatrix, [0.9, 0.9, 0.9 ]);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, ghost3_texture);
            if (power_pellet) {
                gl.bindTexture(gl.TEXTURE_2D, ghostf_texture);
            };
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();


            ////////////////// ghost4 /////////////////////////
            mvPushMatrix();
            mat4.translate(mvMatrix, [2 * x4 + 2, z1 + 2, 2 * y4 + 2]);
            mat4.rotate(mvMatrix, degToRad(80), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(-45), [0, 0, 1]); //rotate gia na se koitaei
            //mat4.scale(mvMatrix, [0.9, 0.9, 0.9 ]);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, ghost4_texture);
            if (power_pellet) {
                gl.bindTexture(gl.TEXTURE_2D, ghostf_texture);
            };
            gl.uniform1i(shaderProgram.samplerUniform, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pacmanVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexTextureCoordBuffer);
            gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, pacmanVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, pacmanVertexNormalBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, pacmanVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pacmanVertexIndexBuffer);
            setMatrixUniforms();
            gl.drawElements(gl.TRIANGLES, pacmanVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            mvPopMatrix();


        }





        function tick() {
            if (!pause) {
                requestAnimFrame(tick);
            }
            handleKeys();
            drawScene();
            animate();


        }


        var pause;

        function webGLStart() {
            var canvas = document.getElementById("game_canvas");
            pause = false;
            initGL(canvas);
            initShaders();
            initBuffers();
            initTexture();
            game_rules();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            document.onkeydown = handleKeyDown;
            document.onkeyup = handleKeyUp;

            tick();
        }


        var lastTime = 0;


        function animate() {

            var timeNow = new Date().getTime();
            if (lastTime != 0) {
                var elapsed = timeNow - lastTime;
                move_conditions(30);
                eat();
                game_conditions(); //win lose points lives etc

            }
            lastTime = timeNow;




        }

        function game_conditions() {
            if (cnt_pellet == 0 && cnt_power == 0) {
                pause = true;
                
				document.getElementById("audio").src="clap.mp3";
				document.getElementById("audio").autoplay=true;
				document.getElementById("audio").play();
				
				
				stage=stage2;
				webGLStart();
				
				//window.location.reload(true);
            }
            if (power_pellet) {
                if ((Math.abs(y1 - y) < 0.5 && Math.abs(x1 - x) < 0.5)) {
                    y1 = 1;
                    x1 = 0;
                    score += 200;
                }
                if ((Math.abs(y2 - y) < 0.5 && Math.abs(x2 - x) < 0.5)) {
                    y2 = 1;
                    x2 = 0;
                    score += 200;
                }
                if ((Math.abs(y3 - y) < 0.5 && Math.abs(x3 - x) < 0.5)) {
                    y3 = 1;
                    x3 = 0;
                    score += 200;
                }
                if ((Math.abs(y4 - y) < 0.5 && Math.abs(x4 - x) < 0.5)) {
                    y4 = 1;
                    x4 = 0;
                    score += 200;
                }

            } else {

                if ((Math.abs(y1 - y) < 0.5 && Math.abs(x1 - x) < 0.5) || (Math.abs(y2 - y) < 0.5 && Math.abs(x2 - x) < 0.5) || (Math.abs(y3 - y) < 0.5 && Math.abs(x3 - x) < 0.5) || (Math.abs(y4 - y) < 0.5 && Math.abs(x4 - x) < 0.5)) {
					//var x=document.getElementById("audio");
                    if (lives == 0) {
                        alert("YOU LOSE! GAME OVER!");
						//var x= document.getElementById("audio");
						//x.src="death.mp3";
						document.getElementById("audio").src="death.mp3";
				
						document.getElementById("audio").autoplay=true;
				document.getElementById("audio").play();
						
						//x.play();
						//x.play();
                        pause = true;
                        window.location.reload(true);
                    } else {
                        lives--;
                        pause = true;
						document.getElementById("audio").src="death.mp3";
				
						document.getElementById("audio").autoplay=true;
				document.getElementById("audio").play();
                        alert("You lost a life. Only " + lives + " remaining...");
                        x = 9;
                        y = 9;
						
                    }
                }

            }
        }


        var x_axis_move = false;

        var index = 1;
        var pathStart = [0, 0];
        var pathEnd = [0, 0];
        var path = [];

        var index2 = 1;
        var pathStart2 = [0, 0];
        var pathEnd2 = [0, 0];
        var path2 = [];

        var index3 = 1;
        var pathStart3 = [0, 0];
        var pathEnd3 = [0, 0];
        var path3 = [];

        var index4 = 1;
        var pathStart4 = [0, 0];
        var pathEnd4 = [0, 0];
        var path4 = [];

        function move_conditions(elapsed) {

            if (memory_key == "W") {
                x = Math.round(x);
                if (stage[Math.round(y) - 1][x] == "x") {
                    ySpeed = 0;
                    xSpeed = 0;
                    y = Math.round(y);
                    x = Math.round(x);
                } else {
                    ySpeed = 6;
                    xSpeed = 0;

                }
                y -= (ySpeed * elapsed) / 1000.0;
                x = Math.round(x);
            }
            if (memory_key == "A") {
                y = Math.round(y);
                if (Math.round(x) == 0) {
                    x = 18;
                }
                if (stage[y][Math.round(x) - 1] == "x") {
                    ySpeed = 0;
                    xSpeed = 0;
                    x = Math.round(x);
                    y = Math.round(y);
                } else {
                    ySpeed = 0;
                    xSpeed = 6;
                }
                x -= (xSpeed * elapsed) / 1000.0;
                y = Math.round(y);

            }
            if (memory_key == "S") {
                x = Math.round(x);
                if (stage[Math.round(y) + 1][x] == "x") {
                    ySpeed = 0;
                    xSpeed = 0;
                    x = Math.round(x);
                    y = Math.round(y);
                } else {
                    ySpeed = 6;
                    xSpeed = 0;
                }
                y += (ySpeed * elapsed) / 1000.0;
                x = Math.round(x);

            }
            if (memory_key == "D") {

                y = Math.round(y);
                if (Math.round(x) == 18) {
                    x = 0;
                }
                if (stage[y][Math.round(x) + 1] == "x") {
                    ySpeed = 0;
                    xSpeed = 0;
                    x = Math.round(x);
                    y = Math.round(y);
                } else {
                    ySpeed = 0;
                    xSpeed = 6;
                }
                x += (xSpeed * elapsed) / 1000.0;
                y = Math.round(y);
            }


            //////////////////////////   GHOST 2 MOVE ///////////////////////
            pathEnd = [Math.round(y), Math.round(x)];
            pathStart = [Math.round(y2), Math.round(x2)];

            path = findPath(stage, pathStart, pathEnd);

            if (memory_key != "R") {

                if (xSpeed == 0 && ySpeed == 0) { //to pacman den kineitai
                    if (path[index][0] == path[index - 1][0]) { //idio y
                        x_axis_move = true;
                        if (path[index][1] > path[index - 1][1]) {

                            x2 += (2 * elapsed) / 1000.0;
                            y2 = Math.round(y2);
                        } else {
                            x2 -= (2 * elapsed) / 1000.0;
                            y2 = Math.round(y2);
                        }
                    }
                    if (path[index][1] == path[index - 1][1]) { //idio x
                        x_axis_move = false;
                        if (path[index][0] > path[index - 1][0]) {
                            y2 += (2 * elapsed) / 1000.0;
                            x2 = Math.round(x2);
                        } else {
                            y2 -= (2 * elapsed) / 1000.0;
                            x2 = Math.round(x2);
                        }
                    }
                } else { //to pacman kineitai
                    index = 1;
                    if (path[1][0] == path[0][0]) { //idio y
                        if (path[1][1] > path[1 - 1][1]) {

                            x2 += (2 * elapsed) / 1000.0;
                            y2 = Math.round(y2);
                        } else {
                            x2 -= (2 * elapsed) / 1000.0;
                            y2 = Math.round(y2);
                        }
                    }
                    if (path[1][1] == path[1 - 1][1]) { //idio x
                        if (path[1][0] > path[1 - 1][0]) {
                            y2 += (2 * elapsed) / 1000.0;
                            x2 = Math.round(x2);
                        } else {
                            y2 -= (2 * elapsed) / 1000.0;
                            x2 = Math.round(x2);
                        }
                    }
                }
            }


            //////////////////////////   GHOST 1 MOVE ///////////////////////
            pathEnd2 = [Math.round(y), Math.round(x)];
            pathStart2 = [Math.round(y1), Math.round(x1)];

            path2 = findPath(stage, pathStart2, pathEnd2);

            if (memory_key != "R") {

                if (xSpeed == 0 && ySpeed == 0) { //to pacman den kineitai
                    if (path2[index2][0] == path2[index2 - 1][0]) { //idio y
                        x_axis_move = true;
                        if (path2[index2][1] > path2[index2 - 1][1]) {

                            x1 += (2 * elapsed) / 1000.0;
                            y1 = Math.round(y1);
                        } else {
                            x1 -= (2 * elapsed) / 1000.0;
                            y1 = Math.round(y1);
                        }
                    }
                    if (path2[index2][1] == path2[index2 - 1][1]) { //idio x
                        x_axis_move = false;
                        if (path2[index2][0] > path2[index2 - 1][0]) {
                            y1 += (2 * elapsed) / 1000.0;
                            x1 = Math.round(x1);
                        } else {
                            y1 -= (2 * elapsed) / 1000.0;
                            x1 = Math.round(x1);
                        }
                    }
                } else { //to pacman kineitai
                    index2 = 1;
                    if (path2[1][0] == path2[0][0]) { //idio y
                        if (path2[1][1] > path2[1 - 1][1]) {

                            x1 += (2 * elapsed) / 1000.0;
                            y1 = Math.round(y1);
                        } else {
                            x1 -= (2 * elapsed) / 1000.0;
                            y1 = Math.round(y1);
                        }
                    }
                    if (path2[1][1] == path2[1 - 1][1]) { //idio x
                        if (path2[1][0] > path2[1 - 1][0]) {
                            y1 += (2 * elapsed) / 1000.0;
                            x1 = Math.round(x1);
                        } else {
                            y1 -= (2 * elapsed) / 1000.0;
                            x1 = Math.round(x1);
                        }
                    }
                }
            }


            //////////////////////////   GHOST 3 MOVE ///////////////////////
            pathEnd3 = [Math.round(y), Math.round(x)];
            pathStart3 = [Math.round(y3), Math.round(x3)];

            path3 = findPath(stage, pathStart3, pathEnd3);

            if (memory_key != "R") {

                if (xSpeed == 0 && ySpeed == 0) { //to pacman den kineitai
                    if (path3[index3][0] == path3[index3 - 1][0]) { //idio y
                        x_axis_move = true;
                        if (path3[index3][1] > path3[index3 - 1][1]) {

                            x3 += (2 * elapsed) / 1000.0;
                            y3 = Math.round(y3);
                        } else {
                            x3 -= (2 * elapsed) / 1000.0;
                            y3 = Math.round(y3);
                        }
                    }
                    if (path3[index3][1] == path3[index3 - 1][1]) { //idio x
                        x_axis_move = false;
                        if (path3[index3][0] > path3[index3 - 1][0]) {
                            y3 += (2 * elapsed) / 1000.0;
                            x3 = Math.round(x3);
                        } else {
                            y3 -= (2 * elapsed) / 1000.0;
                            x3 = Math.round(x3);
                        }
                    }
                } else { //to pacman kineitai
                    index3 = 1;
                    if (path3[1][0] == path3[0][0]) { //idio y
                        if (path3[1][1] > path3[1 - 1][1]) {

                            x3 += (2 * elapsed) / 1000.0;
                            y3 = Math.round(y3);
                        } else {
                            x3 -= (2 * elapsed) / 1000.0;
                            y3 = Math.round(y3);
                        }
                    }
                    if (path3[1][1] == path3[1 - 1][1]) { //idio x
                        if (path3[1][0] > path3[1 - 1][0]) {
                            y3 += (2 * elapsed) / 1000.0;
                            x3 = Math.round(x3);
                        } else {
                            y3 -= (2 * elapsed) / 1000.0;
                            x3 = Math.round(x3);
                        }
                    }
                }
            }


            //////////////////////////   GHOST 4 MOVE ///////////////////////
            pathEnd4 = [Math.round(y), Math.round(x)];
            pathStart4 = [Math.round(y4), Math.round(x4)];

            path4 = findPath(stage, pathStart4, pathEnd4);

            if (memory_key != "R") {

                if (xSpeed == 0 && ySpeed == 0) { //to pacman den kineitai
                    if (path4[index4][0] == path4[index4 - 1][0]) { //idio y
                        x_axis_move = true;
                        if (path4[index4][1] > path4[index4 - 1][1]) {

                            x4 += (2 * elapsed) / 1000.0;
                            y4 = Math.round(y4);
                        } else {
                            x4 -= (2 * elapsed) / 1000.0;
                            y4 = Math.round(y4);
                        }
                    }
                    if (path4[index4][1] == path4[index4 - 1][1]) { //idio x
                        x_axis_move = false;
                        if (path4[index4][0] > path4[index4 - 1][0]) {
                            y4 += (2 * elapsed) / 1000.0;
                            x4 = Math.round(x4);
                        } else {
                            y4 -= (2 * elapsed) / 1000.0;
                            x4 = Math.round(x4);
                        }
                    }
                } else { //to pacman kineitai
                    index4 = 1;
                    if (path4[1][0] == path4[0][0]) { //idio y
                        if (path4[1][1] > path4[1 - 1][1]) {

                            x4 += (2 * elapsed) / 1000.0;
                            y4 = Math.round(y4);
                        } else {
                            x4 -= (2 * elapsed) / 1000.0;
                            y4 = Math.round(y4);
                        }
                    }
                    if (path4[1][1] == path4[1 - 1][1]) { //idio x
                        if (path4[1][0] > path4[1 - 1][0]) {
                            y4 += (2 * elapsed) / 1000.0;
                            x4 = Math.round(x4);
                        } else {
                            y4 -= (2 * elapsed) / 1000.0;
                            x4 = Math.round(x4);
                        }
                    }
                }
            }

            document.getElementById('score').innerHTML = score;
            document.getElementById('lives').innerHTML = lives;



        }

        var power_pellet = false;
        var power_pellet_effect_dur = 10;
        var count_id = 0;
        var score = 0;

        function eat() {
            if (pellet_map[Math.round(y)][Math.round(x)] == "p") {
                cnt_pellet--;
                score += 50;
                pellet_map[Math.round(y)][Math.round(x)] = "0";
            }
            if (pellet_map[Math.round(y)][Math.round(x)] == "U") {
                score += 150;
                power_pellet_effect_dur = 10;
                clearInterval(count_id);
                count_id = setInterval("countdown()", 1000);
                power_pellet = true;
                cnt_power--;
                pellet_map[Math.round(y)][Math.round(x)] = "1";
            }
        }

        function countdown(i) {
            if (power_pellet_effect_dur > 0) {
                power_pellet_effect_dur = power_pellet_effect_dur - 1;
            } else {
                clearInterval(count_id);
                power_pellet = false;

            }
        }


        var cnt_pellet = 0;
        var cnt_power = 0;

        function game_rules() {
			cnt_pellet=0;
			cnt_power=0;
            for (var i = 0; i < 19; i++) {
                for (var j = 0; j < 19; j++) {
                    if (stage[i][j] == "p") {
                        cnt_pellet++;
                    }
                    if (stage[i][j] == "U") {
                        cnt_power++;
                    }
                }
            }
        }
    </script>

    <script>
        $(".pause_resume").click(function() {
            $(this).text(function(i, v) {
                return v === 'Pause' ? 'Resume' : 'Pause'
            })
        });
    </script>


    <style>
        body {
            margin: 0px 0px 0px 0px;
        }
        #debug {
            font-weight: bold;
            text-align: center;
            color: red;
        }
        #game_canvas {
            display: block;
            margin: 0 auto;
        }
        #score {
            position: fixed;
            margin-top: 67px;
            left: 400px;
            font-size: 30px;
        }
        #score_label {
            position: fixed;
            margin-top: 30px;
            left: 400px;
            font-size: 30px;
            color: white;
        }
        hr.divider {
            border: 0;
            height: 3px;
            background-image: -webkit-linear-gradient(left, #bdc3c7, #8c8b8b, #bdc3c7);
            background-image: -moz-linear-gradient(left, #bdc3c7, #8c8b8b, #bdc3c7);
            background-image: -ms-linear-gradient(left, #bdc3c7, #8c8b8b, #bdc3c7);
            background-image: -o-linear-gradient(left, #bdc3c7, #8c8b8b, #bdc3c7);
        }
        .col-md-2.col-lg-2 {
            background-color: #bdc3c7;
            height: 100%;
        }
        .menu_buttons {
            margin-top: 40px;
        }
        .col-md-10.col-lg-10 {
            background-color: black;
            height: 100%;
        }
        #lives_label {
            position: fixed;
            margin-top: 30px;
            right: 400px;
            font-size: 30px;
            color: white;
        }
        #lives_label span {
            color: crimson;
        }
        #lives {
            position: fixed;
            margin-top: 30px;
            right: 380px;
            font-size: 30px;
            color: white;
        }
        
        .panel-body {
            background-color: #bdc3c7;
        }
        #menu_title {
            display: inline-block;
            -webkit-box-sizing: content-box;
            -moz-box-sizing: content-box;
            box-sizing: content-box;
            border: none;
            font-size: 80px;
            color: rgba(48, 48, 48, 1);
            text-align: center;
            text-transform: normal;
            -o-text-overflow: clip;
            text-overflow: clip;
            white-space: pre;
            text-shadow: 1px 1px 0 rgba(140, 140, 140, 0.6), -1px -1px 1px rgba(0, 0, 0, 0.67);
        }
    </style>

</head>


<body onload="webGLStart();">


    <!--    <div class="debug" id="debug"></div>-->

    <div class="col-md-2 col-lg-2">
        <p id="menu_title">Menu</p>
        <div class="menu_buttons">
            <button class='btn btn-primary btn-lg btn-block pause_resume' id="pushme" onclick="if(pause){pause=false;requestAnimFrame(tick);}else{pause=true;}">Pause</button>
            <button type="button" class="btn btn-primary btn-lg btn-block" onclick="window.location.reload(true);">Restart</button>
            <hr class="divider">
            <button type="button" class="btn btn-primary btn-lg btn-block" onclick="panoramic=true;">Panoramic Camera</button>
            <button type="button" class="btn btn-default btn-lg btn-block" onclick="panoramic=false;">TV Camera</button>
            <hr class="divider">
            <button type="button" class="btn btn-primary btn-lg btn-block" onclick="stage=stage1;webGLStart();">Level 1</button>
            <button type="button" class="btn btn-default btn-lg btn-block" onclick="stage=stage2;webGLStart();">Level 2</button>
            <hr class="divider">
            <div class="panel panel-primary">
                <div class="panel-heading">Instructions</div>
                <div class="panel-body">
                    <img class="img img-responsive" src="img/instructions.png">
                </div>
            </div>
<!--
            <button class="btn btn-primary btn-lg btn-block" type="button" data-toggle="collapse" data-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample">Instructions</button>
            <div class="collapse" id="collapseExample">
                <div class="well">
                    
                </div>
            </div>
-->
        </div>
    </div>
    <div class="col-md-10 col-lg-10">
        <div style=" background-image:url(''); width: 100%; height: 100%; border: 0; margin: 0px; overflow: auto;" align="center">
            <canvas id="game_canvas" style="border: none; margin: 30px;" width="1100" height="700"></canvas>
			<audio id="audio" src="clap.mp3"></audio>
        </div>
    </div>
    <p id="score_label">Score</p>
    <div class="odometer" id="score"></div>
    <p class="lives" id="lives_label"><span class="glyphicon glyphicon-heart"></span> Lives:
        <p id="lives"></p>
    </p>



</body>

<script>
    $("#pushme").click(function() {
        $(this).text(function(i, v) {
            return v === 'Pause' ? 'Resume' : 'Pause'
        })
    });
</script>

</html>